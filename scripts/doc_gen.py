#!/usr/bin/env python3
"""
The Scribe - AST-Based CLI Documentation Generator

Glass Box Approach: Uses static analysis to extract CLI command metadata
WITHOUT executing the code. This ensures safety and avoids side-effects.

Usage:
    python scripts/doc_gen.py > docs/CLI.md

@version 2.2.0
"""

import ast
from pathlib import Path
from typing import List, Tuple, Optional


def is_click_command_decorator(decorator: ast.expr) -> bool:
    """
    Check if a decorator is a Click command decorator.

    Matches:
        - @click.command()
        - @cli.command()
        - @command()
        - @click.command
        - @cli.command
    """
    # Handle @decorator() style (Call node)
    if isinstance(decorator, ast.Call):
        func = decorator.func
        # @cli.command() or @click.command()
        if isinstance(func, ast.Attribute):
            return func.attr in ('command', 'group')
        # @command()
        if isinstance(func, ast.Name):
            return func.id in ('command', 'group')

    # Handle @decorator style (Attribute or Name node)
    if isinstance(decorator, ast.Attribute):
        return decorator.attr in ('command', 'group')

    if isinstance(decorator, ast.Name):
        return decorator.id in ('command', 'group')

    return False


def get_command_name_from_decorator(decorator: ast.expr) -> Optional[str]:
    """
    Extract explicit command name from decorator if provided.

    E.g., @cli.command('my-name') returns 'my-name'
    """
    if isinstance(decorator, ast.Call) and decorator.args:
        first_arg = decorator.args[0]
        if isinstance(first_arg, ast.Constant) and isinstance(first_arg.value, str):
            return first_arg.value
    return None


def extract_cli_commands(source_code: str) -> List[Tuple[str, str]]:
    """
    Parse source code and extract CLI command names and descriptions.

    Returns:
        List of (command_name, description) tuples
    """
    tree = ast.parse(source_code)
    commands = []

    for node in ast.walk(tree):
        if isinstance(node, ast.FunctionDef):
            # Check if this function has a click command decorator
            has_command_decorator = False
            explicit_name = None

            for decorator in node.decorator_list:
                if is_click_command_decorator(decorator):
                    has_command_decorator = True
                    explicit_name = get_command_name_from_decorator(decorator)
                    break

            if not has_command_decorator:
                continue

            # Get command name (explicit or from function name)
            if explicit_name:
                cmd_name = explicit_name
            else:
                # Convert underscores to hyphens (Click's standard behavior)
                cmd_name = node.name.replace('_', '-')

            # Get docstring (first line only for summary)
            docstring = ast.get_docstring(node)
            if docstring:
                # Take first line, strip whitespace
                first_line = docstring.split('\n')[0].strip()
                description = first_line
            else:
                description = "(No description)"

            commands.append((cmd_name, description))

    return commands


def generate_markdown_table(commands: List[Tuple[str, str]]) -> str:
    """
    Generate a Markdown table from command list.
    """
    lines = [
        "# Vidurai CLI Reference (Auto-Generated)",
        "",
        "> **Source of Truth** - Generated via AST static analysis from `vidurai/cli.py`",
        "> ",
        "> Last updated: Auto-generated by `scripts/doc_gen.py`",
        "",
        "## Commands",
        "",
        "| Command | Description |",
        "| :--- | :--- |",
    ]

    # Sort commands alphabetically
    for cmd_name, description in sorted(commands, key=lambda x: x[0]):
        # Skip 'cli' (the group itself)
        if cmd_name == 'cli':
            continue
        # Escape pipe characters in description
        safe_desc = description.replace('|', '\\|')
        lines.append(f"| `vidurai {cmd_name}` | {safe_desc} |")

    lines.extend([
        "",
        "---",
        "",
        "*This document is auto-generated. Do not edit manually.*",
        "*Run `python scripts/doc_gen.py > docs/CLI.md` to regenerate.*",
    ])

    return '\n'.join(lines)


def main():
    """Main entry point."""
    # Locate cli.py relative to this script
    script_dir = Path(__file__).parent
    project_root = script_dir.parent
    cli_path = project_root / "vidurai" / "cli.py"

    if not cli_path.exists():
        print(f"ERROR: cli.py not found at {cli_path}", file=__import__('sys').stderr)
        __import__('sys').exit(1)

    # Read source code
    source_code = cli_path.read_text(encoding='utf-8')

    # Extract commands via AST
    commands = extract_cli_commands(source_code)

    # Generate and print markdown
    markdown = generate_markdown_table(commands)
    print(markdown)


if __name__ == "__main__":
    main()
